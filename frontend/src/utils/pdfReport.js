import jsPDF from 'jspdf';
import { getTypeColor, getSeverityColor } from './helpers';

/**
 * Generate a comprehensive PDF report from the analysis results.
 *
 * @param {Object} params
 * @param {Array}  params.uploadedFiles    - Files that were analyzed (may be empty for library-mode).
 * @param {Object} params.analysisResults  - Results object built by UploadPage:
 *   {
 *     contradictions: { high: [...], medium: [...], low: [...] },
 *     totalContradictions: number,
 *     totalClauses: number,
 *     averageConfidence: number,       // 0-100
 *     analysisTime: string,            // e.g. "12s"
 *     isMultiDoc?: boolean,
 *     documents?: [{id, name}],        // multi-doc only
 *     timestamp?: string,
 *   }
 *   Each contradiction item:
 *   {
 *     id, type, severity, description, confidence,
 *     clause_a: { id, text }, clause_b: { id, text },
 *     document_a?: { id, name }, document_b?: { id, name },  // multi-doc only
 *   }
 */
export function generatePDFReport({ uploadedFiles, analysisResults }) {
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - margin * 2;
    const footerHeight = 20;
    const bottomLimit = pageHeight - margin - footerHeight;
    let yPosition = margin;
    const reportId = `SDC-${Date.now()}`;

    // ── Flatten contradictions from grouped object to sorted array ──
    const contras = analysisResults.contradictions || {};
    const severityOrder = ['high', 'medium', 'low'];
    const flatContradictions = [];
    for (const sev of severityOrder) {
        const items = contras[sev];
        if (Array.isArray(items)) {
            items.forEach((item) => flatContradictions.push({ ...item, severity: item.severity || sev }));
        }
    }
    // If contradictions was already a flat array (legacy), use it directly
    if (Array.isArray(contras)) {
        flatContradictions.length = 0;
        contras.forEach((item) => flatContradictions.push(item));
    }

    const highCount = (contras.high || []).length;
    const mediumCount = (contras.medium || []).length;
    const lowCount = (contras.low || []).length;

    const isMultiDoc = !!analysisResults.isMultiDoc;

    // ── Helpers ──
    const addFooter = () => {
        const totalPages = pdf.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
            pdf.setPage(i);
            const fy = pageHeight - footerHeight;
            pdf.setFillColor(248, 250, 252);
            pdf.rect(0, fy, pageWidth, footerHeight, 'F');
            pdf.setDrawColor(226, 232, 240);
            pdf.line(margin, fy, pageWidth - margin, fy);
            pdf.setFontSize(7);
            pdf.setTextColor(100, 116, 139);
            pdf.setFont('helvetica', 'normal');
            pdf.text('Generated by Smart Doc Checker AI v2.1', margin, fy + 8);
            pdf.text(reportId, margin, fy + 13);
            pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, fy + 8);
        }
    };

    const checkPageBreak = (requiredHeight = 20) => {
        if (yPosition + requiredHeight > bottomLimit) {
            pdf.addPage();
            yPosition = margin;
            return true;
        }
        return false;
    };

    const wrapText = (text, maxWidth, fontSize = 10) => {
        pdf.setFontSize(fontSize);
        return pdf.splitTextToSize(String(text || ''), maxWidth);
    };

    const drawSectionTitle = (title) => {
        checkPageBreak(25);
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        pdf.setTextColor(37, 99, 235);
        pdf.text(title, margin, yPosition);
        // underline
        pdf.setDrawColor(37, 99, 235);
        pdf.setLineWidth(0.5);
        pdf.line(margin, yPosition + 1.5, margin + pdf.getTextWidth(title), yPosition + 1.5);
        yPosition += 10;
    };

    const safeText = (val) => String(val ?? '');

    // ═══════════════════════════════════════════════════════════
    // PAGE 1 — Header + Executive Summary
    // ═══════════════════════════════════════════════════════════

    // ── Blue header bar ──
    pdf.setFillColor(37, 99, 235);
    pdf.rect(0, 0, pageWidth, 40, 'F');
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(22);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Smart Doc Checker', margin, 22);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'normal');
    pdf.text(
        isMultiDoc
            ? 'Cross-Document Contradiction Analysis Report'
            : 'Document Contradiction Analysis Report',
        margin,
        32,
    );
    yPosition = 50;

    // ── Metadata row ──
    pdf.setTextColor(0, 0, 0);
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    const reportDate = new Date().toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
    });
    pdf.text(`Generated: ${reportDate}`, margin, yPosition);
    pdf.text(`Report ID: ${reportId}`, margin + 90, yPosition);
    yPosition += 12;

    // ── Executive Summary box ──
    drawSectionTitle('Executive Summary');

    const boxHeight = 46;
    pdf.setFillColor(248, 250, 252);
    pdf.setDrawColor(226, 232, 240);
    pdf.roundedRect(margin, yPosition, contentWidth, boxHeight, 2, 2, 'FD');

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(0, 0, 0);
    const col1 = margin + 5;
    const col2 = margin + contentWidth / 2;
    let sy = yPosition + 8;

    // Determine document count — prefer analysisResults.documents for multi-doc
    const docCount = isMultiDoc && analysisResults.documents
        ? analysisResults.documents.length
        : (uploadedFiles || []).length || '-';

    pdf.setFont('helvetica', 'bold');
    pdf.text('Documents Analyzed:', col1, sy);
    pdf.setFont('helvetica', 'normal');
    pdf.text(String(docCount), col1 + 42, sy);

    pdf.setFont('helvetica', 'bold');
    pdf.text('Total Clauses:', col2, sy);
    pdf.setFont('helvetica', 'normal');
    pdf.text(String(analysisResults.totalClauses || '-'), col2 + 30, sy);

    sy += 8;
    pdf.setFont('helvetica', 'bold');
    pdf.text('Contradictions Found:', col1, sy);
    pdf.setFont('helvetica', 'normal');
    pdf.text(String(analysisResults.totalContradictions || 0), col1 + 44, sy);

    pdf.setFont('helvetica', 'bold');
    pdf.text('Avg Confidence:', col2, sy);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`${analysisResults.averageConfidence || 0}%`, col2 + 33, sy);

    sy += 8;
    pdf.setFont('helvetica', 'bold');
    pdf.text('Analysis Time:', col1, sy);
    pdf.setFont('helvetica', 'normal');
    pdf.text(safeText(analysisResults.analysisTime), col1 + 30, sy);

    pdf.setFont('helvetica', 'bold');
    pdf.text('Analysis Type:', col2, sy);
    pdf.setFont('helvetica', 'normal');
    pdf.text(isMultiDoc ? 'Cross-Document Comparison' : 'Single Document', col2 + 30, sy);

    // Severity breakdown row
    sy += 10;
    pdf.setFont('helvetica', 'bold');
    pdf.text('Severity Breakdown:', col1, sy);
    pdf.setFont('helvetica', 'normal');

    // High badge
    pdf.setFillColor(254, 226, 226);
    pdf.roundedRect(col1 + 42, sy - 3.5, 22, 5, 1, 1, 'F');
    pdf.setTextColor(220, 38, 38);
    pdf.setFontSize(8);
    pdf.text(`High: ${highCount}`, col1 + 44, sy);

    // Medium badge
    pdf.setFillColor(254, 243, 199);
    pdf.roundedRect(col1 + 68, sy - 3.5, 28, 5, 1, 1, 'F');
    pdf.setTextColor(217, 119, 6);
    pdf.text(`Medium: ${mediumCount}`, col1 + 70, sy);

    // Low badge
    pdf.setFillColor(224, 242, 254);
    pdf.roundedRect(col1 + 100, sy - 3.5, 20, 5, 1, 1, 'F');
    pdf.setTextColor(3, 105, 161);
    pdf.text(`Low: ${lowCount}`, col1 + 102, sy);

    pdf.setTextColor(0, 0, 0);
    pdf.setFontSize(10);

    yPosition += boxHeight + 12;

    // ═══════════════════════════════════════════════════════════
    // DOCUMENTS ANALYZED
    // ═══════════════════════════════════════════════════════════
    drawSectionTitle('Documents Analyzed');

    const docList = isMultiDoc && analysisResults.documents
        ? analysisResults.documents.map((d) => ({ name: d.name, meta: '' }))
        : (uploadedFiles || []).map((f) => ({
              name: f.name,
              meta: f.file ? `Size: ${f.size || '-'} | Type: ${f.file.type || '-'}` : '',
          }));

    docList.forEach((doc, index) => {
        checkPageBreak(14);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'bold');
        pdf.setTextColor(0, 0, 0);
        pdf.text(`${index + 1}. ${safeText(doc.name)}`, margin + 5, yPosition);
        if (doc.meta) {
            pdf.setFont('helvetica', 'normal');
            pdf.setFontSize(8);
            pdf.setTextColor(100, 116, 139);
            pdf.text(doc.meta, margin + 10, yPosition + 5);
            yPosition += 12;
        } else {
            yPosition += 8;
        }
    });

    yPosition += 8;

    // ═══════════════════════════════════════════════════════════
    // CONTRADICTIONS DETAIL
    // ═══════════════════════════════════════════════════════════
    if (flatContradictions.length > 0) {
        drawSectionTitle(`Contradictions Detected (${flatContradictions.length})`);

        flatContradictions.forEach((c, index) => {
            // Estimate the height we need for this contradiction block
            const clauseAText = c.clause_a ? c.clause_a.text : '';
            const clauseBText = c.clause_b ? c.clause_b.text : '';
            const descText = c.description || c.explanation || '';
            checkPageBreak(70);

            // ── Contradiction header bar ──
            const severity = (c.severity || 'medium').toLowerCase();
            const sevColors = {
                high: { bg: [254, 226, 226], border: [239, 68, 68], title: [185, 28, 28] },
                medium: { bg: [254, 243, 199], border: [245, 158, 11], title: [146, 64, 14] },
                low: { bg: [224, 242, 254], border: [56, 189, 248], title: [3, 105, 161] },
            };
            const sc = sevColors[severity] || sevColors.medium;

            pdf.setFillColor(...sc.bg);
            pdf.setDrawColor(...sc.border);
            pdf.roundedRect(margin, yPosition, contentWidth, 9, 1, 1, 'FD');
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...sc.title);
            pdf.text(`#${index + 1}`, margin + 3, yPosition + 6);

            // Type badge
            const typeColor = getTypeColor(c.type);
            const typeLabel = safeText(c.type).toUpperCase() || 'UNKNOWN';
            pdf.setFontSize(7);
            pdf.setFont('helvetica', 'bold');
            const typeBadgeW = pdf.getTextWidth(typeLabel) + 4;
            pdf.setFillColor(...typeColor.bg);
            pdf.roundedRect(margin + 16, yPosition + 2, typeBadgeW, 5, 1, 1, 'F');
            pdf.setTextColor(...typeColor.text);
            pdf.text(typeLabel, margin + 18, yPosition + 5.5);

            // Severity badge
            const severityColor = getSeverityColor(severity);
            const sevLabel = severity.toUpperCase();
            const sevBadgeW = pdf.getTextWidth(sevLabel) + 4;
            pdf.setFillColor(...severityColor.bg);
            pdf.roundedRect(margin + 18 + typeBadgeW + 3, yPosition + 2, sevBadgeW, 5, 1, 1, 'F');
            pdf.setTextColor(...severityColor.text);
            pdf.text(sevLabel, margin + 20 + typeBadgeW + 3, yPosition + 5.5);

            // Confidence
            pdf.setTextColor(0, 0, 0);
            pdf.setFontSize(8);
            pdf.setFont('helvetica', 'normal');
            const confStr = `Confidence: ${Math.round(c.confidence || 0)}%`;
            pdf.text(confStr, margin + contentWidth - pdf.getTextWidth(confStr) - 3, yPosition + 5.5);

            yPosition += 14;

            // ── Source A ──
            const labelA = isMultiDoc && c.document_a ? c.document_a.name : 'Clause A';
            pdf.setFontSize(9);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(37, 99, 235);
            pdf.text(safeText(labelA), margin + 3, yPosition);
            yPosition += 4;

            if (clauseAText) {
                pdf.setFont('helvetica', 'normal');
                pdf.setFontSize(8);
                pdf.setTextColor(55, 65, 81);
                const wrappedA = wrapText(`"${clauseAText}"`, contentWidth - 10, 8);
                wrappedA.forEach((line) => {
                    checkPageBreak(5);
                    pdf.text(line, margin + 5, yPosition);
                    yPosition += 3.5;
                });
                yPosition += 2;
            }

            // ── Source B ──
            checkPageBreak(15);
            const labelB = isMultiDoc && c.document_b ? c.document_b.name : 'Clause B';
            pdf.setFontSize(9);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(37, 99, 235);
            pdf.text(safeText(labelB), margin + 3, yPosition);
            yPosition += 4;

            if (clauseBText) {
                pdf.setFont('helvetica', 'normal');
                pdf.setFontSize(8);
                pdf.setTextColor(55, 65, 81);
                const wrappedB = wrapText(`"${clauseBText}"`, contentWidth - 10, 8);
                wrappedB.forEach((line) => {
                    checkPageBreak(5);
                    pdf.text(line, margin + 5, yPosition);
                    yPosition += 3.5;
                });
                yPosition += 2;
            }

            // ── Description / explanation box ──
            if (descText) {
                checkPageBreak(16);
                pdf.setFillColor(255, 251, 235);
                pdf.setDrawColor(245, 158, 11);
                const descLines = wrapText(descText, contentWidth - 14, 8);
                const descBoxH = descLines.length * 3.5 + 8;
                pdf.roundedRect(margin, yPosition, contentWidth, descBoxH, 1, 1, 'FD');
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(146, 64, 14);
                pdf.text('Analysis:', margin + 3, yPosition + 4);
                pdf.setFont('helvetica', 'normal');
                let descY = yPosition + 8;
                descLines.forEach((line) => {
                    pdf.text(line, margin + 3, descY);
                    descY += 3.5;
                });
                yPosition += descBoxH + 8;
            } else {
                yPosition += 6;
            }
        });
    } else {
        // No contradictions
        drawSectionTitle('Contradictions Detected');
        pdf.setFontSize(11);
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(22, 163, 74);
        pdf.text(
            isMultiDoc
                ? 'No cross-document contradictions were detected. Documents appear consistent.'
                : 'No contradictions were detected. The document appears internally consistent.',
            margin + 5,
            yPosition,
        );
        yPosition += 15;
    }

    // ═══════════════════════════════════════════════════════════
    // DATA-DRIVEN RECOMMENDATIONS
    // ═══════════════════════════════════════════════════════════
    checkPageBreak(40);
    drawSectionTitle('Recommendations');

    const recommendations = [];
    if (highCount > 0) {
        recommendations.push(
            `${highCount} high-severity contradiction(s) require immediate attention and resolution before document finalization.`,
        );
    }
    if (mediumCount > 0) {
        recommendations.push(
            `${mediumCount} medium-severity contradiction(s) should be reviewed and reconciled in the next revision cycle.`,
        );
    }
    if (lowCount > 0) {
        recommendations.push(
            `${lowCount} low-severity contradiction(s) detected — verify whether differences are intentional.`,
        );
    }
    if (flatContradictions.length === 0) {
        recommendations.push('No contradictions found — document(s) appear consistent.');
    }
    // Generic best practices
    recommendations.push(
        'Implement version control and periodic cross-document reviews to prevent future contradictions.',
    );
    if (isMultiDoc) {
        recommendations.push(
            'Consider creating a master reference document to serve as the canonical source of truth across all related documents.',
        );
    }

    recommendations.forEach((rec, i) => {
        checkPageBreak(12);
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(0, 0, 0);
        const recLines = wrapText(`${i + 1}. ${rec}`, contentWidth - 10, 9);
        recLines.forEach((line) => {
            checkPageBreak(5);
            pdf.text(line, margin + 5, yPosition);
            yPosition += 4;
        });
        yPosition += 2;
    });

    // ── Add footer to all pages ──
    addFooter();

    // ── Save ──
    const fileName = `smart-doc-analysis-${Date.now()}.pdf`;
    pdf.save(fileName);
}
